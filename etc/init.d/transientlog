#!/bin/sh

### BEGIN INIT INFO
# Provides:          varlog
# Required-Start:    $local_fs
# Required-Stop: $local_fs
# X-Start-Before:  $syslog
# X-Stop-After:    $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Set up transient var/log
# X-Interactive:   yes
### END INIT INFO

# based on http://www.debian-administration.org/article/661/A_transient_/var/log
# and debian tmpfs for /var/run and /var/lock

# Config:
RAMDIR=/var/log
SOLIDDIR=/var/.log-solid

# Return
#   0 if transient log has been started
#   1 if transient log was already running
#   2 if transient log could not be started

NAME=varlog
DESC=$NAME
RAMNAME=`echo $RAMDIR | sed s@/@@g`
RAMLOCK=$RAMDIR/.ramfs

# Load the VERBOSE setting and other rcS variables
. /lib/init/vars.sh

# Define LSB log_* functions.
# Depend on lsb-base (>= 3.0-6) to ensure that this file is present.
. /lib/lsb/init-functions



do_start()
{
    [ -f $RAMLOCK ] && return 1
    [ `id -u` -eq 0 ] || return 2
    [ -d $RAMDIR ] || return 2
    
    # bind the original directory before putting up the ramdisk
    mount --bind $RAMDIR $SOLIDDIR

    # bring up the ramdisk
    mount -t tmpfs -o nosuid,noexec,nodev,mode=0755 $RAMNAME $RAMDIR

    # if it worked ok, populate the ramdisk
    if [ $? -eq 0 ]; then
	cp -rfp $SOLIDDIR/* $RAMDIR/
	touch $RAMLOCK
	return 0
    fi

    # if we get here, it means something went wrong, so cancel previous mounts
    umount $RAMDIR
    umount $SOLIDDIR
    return 2
}


do_stop() {
        # Return
        #   0 if transient log has been stopped
        #   1 if transient log was already stopped
        #   2 if transient log could not be stopped
        #   other if a failure occurred

        [ -f $RAMLOCK ] || return 1
        [ `id -u` -eq 0 ] || return 2

        # Merge back to permanent storage
	rm -f $RAMLOCK
        cp -rfup $RAMDIR/* $SOLIDDIR/

        umount -l $RAMDIR
        umount -l $SOLIDDIR
	
        return 0
}

do_save() {
        # Return
        #   0 if transient log has been saved
        #   1 if transient log was not running
        #   2 if transient log could not be saved

        [ -f $RAMLOCK ] || return 1
        [ `id -u` -eq 0 ] || return 2

        # Merge back to permanent storage
	rm -f $RAMLOCK
        cp -rfup $RAMDIR/* $SOLIDDIR/
	touch $RAMLOCK

        return 0
}



case "$1" in
  start)
	[ "$VERBOSE" != no ] && log_daemon_msg "Starting $DESC" "$NAME"
	do_start
	case "$?" in
		0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
		2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
	esac
	;;
  stop)
	[ "$VERBOSE" != no ] && log_daemon_msg "Stopping $DESC" "$NAME"
	do_stop
	case "$?" in
		0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
		2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
	esac
	;;
  status)
  	if [ -f $RAMLOCK ]; then
		echo "tmpfs varlog is on"
	else
		echo "tmpfs varlog is off"
		exit 1
	fi
	;;
  reload)
	log_daemon_msg "Reloading $DESC" "$NAME"
	do_save
	log_end_msg $?
	;;
  *)
	echo "Usage: $0 {start|stop|status|reload}" >&2
	exit 3
	;;
esac


# EOF