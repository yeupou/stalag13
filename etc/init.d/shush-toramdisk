#!/bin/sh

### BEGIN INIT INFO
# Provides:          varlog
# Required-Start:    $local_fs
# Required-Stop: $local_fs
# X-Start-Before:  $syslog
# X-Stop-After:    $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Silence the hard disk by using ramdisk for /var/log and others
# X-Interactive:   yes
### END INIT INFO

# Based on
# http://www.debian-administration.org/article/661/A_transient_/var/log
# and debian tmpfs for /var/run and /var/lock
# but also handle one or more user directories

NAME=shush-toramdisk
DESC="hard disk silencer" 
RAMDIRS=/var/log

# Include defaults if available
if [ -f /etc/default/$NAME ] ; then
    . /etc/default/$NAME
fi

# Return
#   0 been started or already running
#   1 failure

# Load rcS variables
. /lib/init/vars.sh

# Define LSB log_* functions.
# Depend on lsb-base (>= 3.0-6) to ensure that this file is present.
. /lib/lsb/init-functions

do_start()
{
    # not root? fail
    [ `id -u` -eq 0 ] || return 2

    # set default return value to success
    RETURN=0
    
    # proceed for each directory
    for RAMDIR in $RAMDIRS; do
	RAMNAME=`echo $RAMDIR | sed s@/@@g`
	RAMLOCK=/var/lock/shush$RAMNAME.lock
	SOLIDDIR=`dirname $RAMDIR`/.`basename $RAMDIR`-solid
	
	# there is a fishy lock, fail with warning
	[ -h $RAMLOCK ] && RETURN=1 && continue

	# there is lock already, assumes this RAMDIR is already on
	[ -f $RAMLOCK ] && continue
	
	# RAMDIR non-existant? silent fail
	[ -d $RAMDIR ] || continue
	
	# keep ownership and mode
	DIRMODE=`stat -c "%a" $RAMDIR`
	DIRUID=`stat -c "%u" $RAMDIR`
	DIRGID=`stat -c "%g" $RAMDIR`
	
	# SOLIDDIR non-existant? build it
	[ -d $SOLIDDIR ] || mkdir $SOLIDDIR
	chmod $DIRMODE $SOLIDDIR
	chown $DIRUID:$DIRGID $SOLIDDIR
    
	# bind the original directory before putting up the ramdisk
	mount --bind $RAMDIR $SOLIDDIR

	# find out the directory size to set a sensible ramdisk size
	
	# bring up the ramdisk
	mount -t tmpfs -o nodev,uid=$DIRUID,gid=$DIRGID,mode=$DIRMODE $RAMNAME $RAMDIR

	# if it worked ok
	if [ $? -eq 0 ]; then
	    # set a lock
	    set -o noclobber && echo > $RAMLOCK && set +o noclobber
	    # populate the ramdisk
	    cp -rfp $SOLIDDIR -T $RAMDIR
	    continue
	fi
	
	# if we get here, it means something went wrong
	# so cancel previous mounts
	umount $RAMDIR
	umount $SOLIDDIR
	# and set a fail return value
	RETURN=1
    done
    return $RETURN
}


do_stop() {
    # not root? fail
    [ `id -u` -eq 0 ] || return 2

    # set default return value to success
    RETURN=0
    
    # proceed for each directory
    for RAMDIR in $RAMDIRS; do
	RAMNAME=`echo $RAMDIR | sed s@/@@g`
	RAMLOCK=/var/lock/shush$RAMNAME.lock
	SOLIDDIR=`dirname $RAMDIR`/.`basename $RAMDIR`-solid
	
	# there is no lock, assumes this RAMDIR is already off
	[ -f $RAMLOCK ] || continue
	
	# there is a fishy lock, fail with warning
	[ -h $RAMLOCK ] && RETURN=1 && continue
	[ ! -f $RAMLOCK ] && RETURN=1 && continue
	
	# RAMDIR non-existant? silent fail
	[ -d $RAMDIR ] || continue

        # Merge back to permanent storage
	rm -f $RAMLOCK
        cp -rfup $RAMDIR -T $SOLIDDIR

	# unmount it all
        umount -l $RAMDIR
        umount -l $SOLIDDIR

	# remove the solid directory now useless, if empty
	rm -d $SOLIDDIR
    done
    return $RETURN
}

do_save() {
    # not root? fail
    [ `id -u` -eq 0 ] || return 2


    # set default return value to success
    RETURN=0
            
    # proceed for each directory
    for RAMDIR in $RAMDIRS; do
	RAMNAME=`echo $RAMDIR | sed s@/@@g`
	RAMLOCK=/var/lock/shush$RAMNAME.lock
	SOLIDDIR=`dirname $RAMDIR`/.`basename $RAMDIR`-solid

	# there is no lock, assumes this RAMDIR is off
        [ -f $RAMLOCK ] || continue

	# there is a fishy lock, fail with warning
	[ -h $RAMLOCK ] && RETURN=1 && continue
	[ ! -f $RAMLOCK ] && RETURN=1 && continue
	
	# RAMDIR non-existant? silent fail
	[ -d $RAMDIR ] || continue
	
        # Merge back to permanent storage
	rm -f $RAMLOCK
        cp -rfup $RAMDIR -T $SOLIDDIR
	set -o noclobber && echo > $RAMLOCK && set +o noclobber
    done
    return $RETURN
}



case "$1" in
    start)
	[ "$VERBOSE" != no ] && log_daemon_msg "Starting $DESC" "$NAME"
	do_start
	case "$?" in
	    0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
	    2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
	esac
	;;
    stop)
	[ "$VERBOSE" != no ] && log_daemon_msg "Stopping $DESC" "$NAME"
	do_stop
	case "$?" in
	    0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
	    2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
	esac
	;;
    status)
	# proceed for each directory
	for RAMDIR in $RAMDIRS; do
	    RAMNAME=`echo $RAMDIR | sed s@/@@g`
	    RAMLOCK=/var/lock/shush$RAMNAME.lock
            if [ -f $RAMLOCK ]; then
		echo "$RAMDIR is shushed/on ramdisk"
	    else
		echo "$RAMDIR is not shushed/on ramdisk"
	    fi
	done
	;;
    reload)
	log_daemon_msg "Reloading $DESC" "$NAME"
	do_save
	log_end_msg $?
	;;
    *)
	echo "Usage: $0 {start|stop|status|reload}" >&2
	exit 3
	;;
esac


# EOF
